# Dino Tower Defense

#### Introduction

Rather than Quadris, our group decided to create a tower defense game heavily inspired by Bloons Tower Defense. The idea is to place towers to kill enemies, preventing them from traversing the path from start to finish. 

#### Overview

The overarching pattern for game logic relies on the observer pattern so that enemies can be attacked by the appropriate towers on every frame of a round. Before starting a round, the user can buy and upgrade towers. After starting the round, the user can only press next to look at the game play frame by frame or press skip to finish the round. During the round, the enemies enter the path and get attacked by towers placed on the land. The game ends when the user either loses all the `hp` or reaches the maximum number of rounds available.

In *Dino Tower Defense*, the user has two base stats - `hp` and money. Money is used to buy towers from the shop and upgrade any existing towers. There are three types of towers: damage, freeze, and money - that inherit from the Tower interface. The damage tower damages enemies and can be upgraded to deal more damage. The freeze tower can stop enemy movement for a certain duration of time which can also be upgraded. Lastly, the money tower generates passive income, also upgradeable, each round. As well, there are three types of enemies: basic, regenerative, and invisible - that inherit from the Enemy interface.

Towers and enemies can exist on the map on the land and path tiles respectively. So, the Map class owns multiple Tile objects where each tile can be a `LandTile` or a `PathTile`. The map generator creates a random path that will be followed by the fleet of Enemy objects on every round. There is a shop where the three types of towers may be bought by dragging and dropping the desired tower onto a specific tile in the map in the GUI. As for the textual interface, x and y coordinates specify locations for the tower placement.

Overall, the State class owns the map, enemies, towers and shop which controls the money and `hp`. Upon losing all the `hp`, the game ends and the State frees all the classes it owns. 

#### Updated UML

Some aspects of the UML were changed from the old design. There are some extra classes created along with a change in design patterns for certain classes. Instead of using both the decorator pattern and the factory method pattern for the towers, the decorator pattern was removed because upgrades of changing types were not in the scope of the project. The `spawner` class was added to generate adaptive enemies as an extra feature to the game.  As well, now the State class owns the Shop, Map, vector of Enemy objects, vector of `Tower` objects and `Spawner`. Since these classes should not exist without the existence of the game state, it makes sense to have these classes exist under State. In order to build out the graphical interface of the game, the View class is introduced as a client class that owns a game State. In order to modularize the visual representation of the map, the `TileView` class holds information about each tile on the map and updates the graphics upon any user mouse input.

In the new design, the observer pattern is used so that all Enemy objects can observe all Tower objects on each frame of a round. Hence, the added classes in order for the Enemy and Tower classes to inherit from the Observer and Subject classes.

#### Design

Many software design principles can be found in our implementation, and will be demonstrated. 

###### Open Closed Principle

The ‘Open Closed Principle’ can be briefly defined as the principle that a module should be open for extension but closed to modification.

Our current design has two fundamental objects - towers and enemies. The two are the basis to all tower defense games. As such, many other modules depend on the implementation of towers and enemies - most specifically the game state, UI and the map. Thus, the ‘Open Closed Principle’ is important to the implementation of towers and enemies to allow for private changes to the objects to not affect the dynamic between the objects and dependent modules. Any client reference to towers or enemies depend on the abstract classes, rather than the specific implementations of the derived classes. Through a well-defined public interface, it allows for us to make changes to derived classes without needing to change the client-object code as well. We utilized dynamic polymorphism in both towers and enemies to allow method overriding for each of the derived classes. This enabled each of the derived towers (money, freeze, damage), and enemies (basic, regenerative, invisible) to have behaviors specific to their type while fulfilling the public virtual interface.  

###### Inheriting Interface vs Implementation

As inheritance was used in both the tower and enemy objects, both aspects of implementation and an inheriting interface were used. Ideally, the abstract base class designer determines what parts of the member function the derived class inherits. There are three primary design patterns,

1. Interface (declaration) of member function

2. Interface and (default) overridable implementation

3. Interface and non-overridable implementation

and it will be shown that in the tower entity, the patterns are used in the appropriate scenarios. 

With respect to the tower entity, declaration of member functions are utilized for ‘getters’ of derived-class specific fields. Such fields include cost, upgrade cost, and description. By using templating in the base class, it allows for references to the base class to return derived-class specific fields since they all share the same fields but with different values. For example, the upgrade cost for the damage tower and freeze tower scale at different rates due to the difference in how upgrades affect the tower. However, this should not affect the base implementation, so the declaration of the member function is in the abstract base class.

No instances of default overridable implementations are found in the tower entity. This is primarily due to the fact that there are no behaviors defined in the abstract base tower that need to be overridden. Given the primary shared feature between the towers in shooting is implemented using the observer-subject pattern, then there are no more behaviors shared between the towers to be implemented in the base class. Non-overridable implementations for functions are utilized for getters, and the `attack()` method, which enables towers to shoot enemies within range. A non-overridable implementation was chosen for `attack()` since the observer and subject design pattern was chosen for the interactions between towers and enemies. Whenever a tower attacks, it notifies all the observing enemies. Thus, there is no reason to allow for overridability, since every frame towers simply notify all enemies within range. 

###### Liskov Substitutability Principle (LSP)

In our design, `Tile` conforms to the 'Liskov Substitutability Principle (LSP)'. As such, clients are able to completely substitute a Tile for either a `PathTile` or a `LandTile` while preserving the behavior of a Tile. This is demonstrated as the derived classes both have methods that report on the location and current occupancy of the tile.	

`LandTile` and `PathTile` both accept Tile's messages, require no more than the base class' methods and promise no less than the Tile's methods. All of Tile's messages are accepted by the derived classes since they overwrite all of Tile's methods - `location()` and `isOccupied()`. Furthermore, these overwritten methods have signatures with matching parameters, return values, and the exceptions matching the base class. Additionally, `PathTile` and `LandTile` have no preconditions to retrieve either the location or occupancy, so they require no more than Tile. Finally, as the only postcondition on `isOccupied()`and `location()` is that the object is not mutated, and the derived classes both do not mutate the object through `isOccupied` and `location` -  declared with the keyword `const` - the methods promise no less than the Tile's methods.

Now, to truly be substitutable according to LSP, Tile's invariants must also be present in its derived classes. The only invariant in Tile is that its location cannot be changed during its lifetime, and since this invariant is preserved in both `PathTile` and `LandTile`, Tile and its derived classes follow the 'Liskov Substitutability Principle'. 

###### "Law" of Demeter	

In the design of the View class responsible for the GUI, the class acted as a client to the game logic. As such, several methods and attributes were needed to be retrieved in order to display the information graphically. Since the View class owns a State class, it only talks to the State class. For example, the View class needs to access a tower in a certain location. Rather than getting the Map object from the State object and then linking a call to the Map object's `getTower` function, the State object is responsible for calling the Map object's `getTower` function. This prevents the View class from accessing methods and attributes of a class that is not its neighbor.

#### Resilience to Change

In the implementation of our game, we utilized multiple software design principles to keep the program resilient to change. The idea is, in brief, to allow for fast and easy future changes without having to re-factor or change older code. 

First, we have the principle of high cohesion within each module, meaning that all components of the module work together to complete one specific task. As such, when code needs to be changed, a bug needs to be patched, or a feature needs to be added, only one module needs to be changed. This allows code to be more resilient to change as logic changes in module are localized to that single module.

In our program, high cohesion is put on full display in the map module. Here, any and all logic changes regarding enemy movement, map generation, and tile interactions are handled directly through map. Furthermore, as map should not handle anything regarding the specific location of any enemies or towers, this logic is put directly in their respective modules. So, by using high cohesion, map fully encompasses all required functions of a map without encroaching on other module's domain of influence. Therefore, only the features regarding map are placed within its module, allowing for its logic to be isolated and easy to trace.

Furthermore, `spawner` handles everything regarding enemy generation. Instead of state figuring out which enemies to create and of what type, the `spawner` module is responsible for all of this logic. By isolating the logic, we were able to develop the adaptive enemy generation feature quickly, introduce balance changes with ease, and squash bugs in no time at all. Therefore, by introducing high cohesion, we were able to isolate logic regarding a specific feature to a single module, making our modules extremely resilient to change. 

All in all, high cohesion allowed our modules to stay compact and isolate feature logic to a single module. This allows our code to be easily extendable for future development, and extremely easy to track logic errors. 

Secondly, we utilize the principle of low component coupling, which can be defined in that any two modules will have low interconnectedness. Ideally, components should not rely on the implementation details of other components, but instead, only really requiring what is being returned. This concept was critical in the implementation of the game due to the split of the workload where we had members working on map and state concurrently, thus low coupling was required to prevent blocking one another. In only requiring return types and not caring about implementation details, code could be written knowing that the implementation details of the other side would not break anything, as long as the return type was agreed upon between the two parties. 

The principles of low coupling will be described in detail as seen in the state component, as it is essentially the glue that holds all the other components together. State has two primary other components in which it was ensured that it was loosely coupled to - `map` and `spawner`. The map controls all map functionality, including both path and tile functionality. The `spawner` controls level generation per round - an homage to mob spawners in minecraft.

It is important to have low coupling between the map and the state because the state should only handle pure game functionality, and thus changes to maps or even deeper tiles must not break the game. With state only interacting with the public interface of the map, we can ensure that the two are not deeply coupled. Moreover, given the sheer number of interactions per round between state and round, it will be shown that the principle of low coupling is visible throughout. At the start of every frame, the game state must move the enemies on the map. However, this is done in a very loosely coupled manner - the map moves the enemies, and returns the enemies who have escaped through a function call (getter). Furthermore, if enemies must be sent to the first square they are sent to the map from the stack of enemies to spawn (setter). Thus, state knows of no implementation details as to how the map moves enemies, or calculates enemies who’ve escaped, only taking a vector of enemies. After the enemies have been moved, and shot by the towers within range, once again a function call (getter) is sent to map requesting the enemies who have died. Loose coupling between state, map, and enemy makes this process highly resilient to change. 

Likewise, it is important for there to be low coupling between state and spawner. This ensures that changes to how we decide to adjust level difficulty - changing max enemy HP, enemy distribution, etc. does not impact the functionality of the game. This is ensured through there only being three spawner calls in the game state - to retrieve enemies for the level (getter), retrieve bonus gold (getter), and to give feedback as to the player’s performance on the round (setter). Through utilizing the ‘getter’ and ‘setter’ pattern, as long as the return type of the function stays constant through future changes, it can be assured that the two components are in a state of low coupling. In short, state knows nothing as to the specifics in enemy generation per round, only knowing the return type (```vector<Enemy*>```) to then send to the map upon the commencement of every round. 

Lastly, for the implementation of our base objects - towers and enemies - we decided to not have them control their location. Thus, enemies does not know where on the path it is, and a tower does not know which tile (x, y) it is placed on. This approach to the design of the towers and enemies allows low coupling between the entities and the map. Essentially, towers and enemies are decoupled from the rest of the game implementation, as they exist as standalone entities having no control of their movement. This ensures there are no references to map, tile, or state in towers and enemies. Therefore, we can be sure that future changes in our towers or enemies - whether it be adding new features or changing implementation details, will not break any other components because they essentially only know of their own existence. Lastly, it allows for the game state to own towers and enemies while the map controls their functionality, because the state should create and destroy the enemies. Having stand-alone entities enables a high degree of low coupling allowing for proper entity management. 

A high degree of cohesion and low coupling between components are examples of how our implementation demonstrates strong inter-component software design principles. Moving on, it will be demonstrated that the principles of `PIMPL` and `NVI` are used for strong intra-component software design. 

PIMPL, or `Pointer to Implementation` ensures that all the private fields are stored within a struct, and the class has a pointer to that implementation. With our main classes - state, map, spawner, and shop - we utilize PIMPL to encapsulate private fields. This ensures that there is low amounts of re-compilation required when we add new fields to the PIMPL. Moreover, it allows the classes to be movable and copyable, in case the big 5 must be implemented in the future. 

NVI, or ‘Non-Virtual Interface’ enables easy refactoring of before and after code fragments in the base class. NVI was implemented in the classes that utilized inheritance - enemy, tower, and tile. Interfaces were made public, virtual functions were made private, only virtual functions that the derived classes needed to access were made private, and base class destructors were all public and virtual. Through using NVI, we can check invariants before and after virtual function executions, ensuring that changes to virtual functions do not break the overlying behaviour - making it resilient to changes (can detect errors). Moreover, if invariants change, the implementation of the virtual functions do not need to change as well. 

All in all, we hope the software principles applied to both inter-component and intra-component design help make the implementation resilient to change. Ideally, the principles of high cohesion, loose coupling, PIMPL, and NVI help ensure that both new features and changes to existing features can be swiftly, and easily implemented. However, as programmers we know that our implementation is not perfect, and can always use improvements. When printing, it would have been better to use the notify and observer pattern and virtual functions rather than overloading the operator. This would prevent needing to know the type of the object being printed, allowing for stronger resilience to change in the future. Moreover, the interactions between state and view (UI) could possibly have improved using the notify and observer pattern. The view class should be notified when there are changes to game state, so that the user interface can be appropriately updated. Ideally, it would create a pushing model (state pushes to view), rather than a polling model that we implemented (view polls changes in state). Thus, when changes are made to the state’s implementation, it would not affect the view class (similar to loose coupling between state and view). 

#### Answers to Project Specification

###### Questions

1. If a tower were to stop shooting after a certain number of enemies enter its vicinity, it should call an overridden `canShoot()` method - strategy pattern -  to determine if its number of observers is less than the certain number of enemies. Only if `canShoot()` returns in the affirmative, can we target an observer.
   The basic principle behind enemy generation is that a random number is generated between 0 to the current level, that number is then used to determine which type of enemy is generated. For example, if the number 5 was generated, then the basic enemy would be created as it has a corresponding range of [0,10). In this model, the regenerative enemy can be given a range with a lower bound of the level that you want this enemy to start appearing. Doing so, confines the regenerative enemy to this level.

2. Recompilation is needed when class dependencies change or when additional functions must be called. To accommodate the possibility of introducing additional levels into the system, we must use the strategy pattern to allow overriding current functionality. For example, if we would want to add forks into the path as the levels proceeded, the base class must include a private virtual `modifyPath()` function which will be overridden in the additional level to perform different functionality.
   Therefore, to introduce additional levels into the system, with no recompilation, we would just have to override the base class' functions. Then this additional level "is-a" level, and so, the dependencies between the classes are exactly the same and  no compilation is required  As such, we have minimized recompilation by using the strategy pattern. 

3. To buy a tower, we must explicitly provide both the type and location. Commands are provided only in the shop, where specific keys represent different types of towers. To be able to add/rename commands with minimal changes to source and minimal recompilation, we will need a map between commands and the type of the tower. Initially, the map has the default mappings (ie. `a -> attack tower`, `d -> debuff tower, m -> money tower`), and commands are added as required.
   A "macro" language then would be implemented as a map that fully describes the association between a set of characters, and its designated tower types. 

#### Extra Credit Features

In our project, we have two main features that we feel go beyond the scope of a normal tower defense game.

###### Dynamic Difficulty Adjustment

In the base game, the `spawner` object generates enemies on a quadratic scale with respect to round. For every round, n, there are n enemies generated with n HP each. This allows the rounds to get more and more difficult, however the game then falls into the state of predictability. At every round, though the distribution of enemies may be random, the amount and HP of each is purely dependent on round. Thus, this makes for a rather boring game over time - one that becomes very, very repetitive. Therefore, we strived to implement a ‘dynamic difficulty adjustment’, that adjusts the difficulty of the game based on the ability of the player and their skill level. Dynamic difficulty adjustment is important because it makes the game ‘fun for everyone’. It was challenging to think of an algorithm that could change the difficulty according to player performance. In the end, the functionality was implemented with the assistance of a research paper,  *Dynamic Difficulty Adjustment in Tower Defense* (Sutoyo et al.) which can be found in the citation below. Essentially, it measures the ability of the player at the end of every round through measurements of HP lost and % enemy HP remaining. Though they are very similarly correlated, differences can be imagined between the two when the player has high HP (% enemy HP more important) against when the player has low HP (HP lost more important). Points are kept affecting status, difficulty, gold, and spawn rates, with additional multipliers for each. Player HP lost and % enemy HP remaining are evaluated after every round, changing the points and multipliers. This affects the max HP, horde size, and gold generation per round, allowing for more dynamic gameplay. 

###### Unique Path Generation	

Normally in tower defense games, all of the maps are pre-generated, creating a rather boring user experience for seasoned player. To solve this issue, we decided to implement a basic path generation algorithm for the base game and an advanced path generation algorithm for the featured game. To generate more interesting paths, simply add the `--map` flag to the CLI. The challenge with generating a completely random path was the problem of avoiding loops and avoiding paths with square paths (2x2 path tiles). This was solved using a recursive backtracking algorithm along with a map containing whether a tile had been already visited. By checking whether your current square is surrounded by three other path tiles, we are able to avoid 2x2 path tiles. Also, by checking whether the current tile has already visited, we can avoid creating loops. Finally, by pushing a random next path location onto the recursion stack using `srand()` and `rand()`, we were able to ensure that no two generated maps are exactly the same. 

#### Retrospective Questions

###### What lessons did this project teach you about developing software in teams? 

Teamwork in software development required much more coordination and communication that we thought. It was very helpful to use git for version control so that all three team members could work separately on different features using branches. As well, new features were not merged into the master branch until the pull request is approved by a fellow team member. There were several instances where errors and misconceptions were cleared through the use of effective code reviews. As well, we encountered several merge conflicts when trying to merge new features or bug fixes into the master branch. We learned that it was helpful to keep a backup branch when rebasing a branch because the rebasing process rewrites the version history of a branch. Even better, we realized that it was safer to merge rather than rebase branches onto the master branch to keep the version history intact. Throughout the software development process, it was important to keep a clean and working master branch at all times so that there was a version of the code to refer to whenever something went wrong. This especially helped when there were segmentation faults or logic errors that were very hard to debug. We could simply revert back to the latest working version of the code and make small incremental changes to test out what breaks the code.

Finally, we learned that it was important to split up the work logically so that each team member is responsible for a portion of the code that is cohesive. So the team can focus on how the pieces fit together during team meetings rather than implementation details. All in all, teamwork in this project was very smooth thanks to git and splitting up the work logically.

###### What would you have done differently if you had the chance to start over?

If we had the chance to start over, we would first discuss and agree on the basics of how a grid should be laid out by using rows and columns or a cartesian plane. This would have made the development with client code much easier, especially with the use of an iterator. Not to mention, there should have been better communication between the UI team and the backend team from the start. Cross team communication was inadequate because there were missing functionalities and specifications that were not implemented when required.

As well, more thought should have been put into researching an appropriate UI library. This is because gtkmm was recommended in the course resources but not installed properly on the linux server. Rather, there was only a proper installation of the library on the Ubuntu1604 machines which wasted a lot of time. In addition to installation problems, the gtkmm library has memory leaks. This was found to be true when running the hello world example from the gtkmm 3.0 documentation. As a result, we could not properly implement a game that was free of memory leaks for extra credit.

Lastly, we could have implemented a more intuitive textual interface that clears itself on each round as well as make it more user friendly by limiting the data displayed. The GUI could have incorporated animations for the incoming enemies instead of a next button to make the game flow faster.

#### Conclusion

Throughout the development process, thinking through design principles and patterns allowed us to create code that was easy to maintain and change. Collaborating with group members made the abstraction of code a necessary means of communication between members of our team. Designing a game that was both challenging and fun required much thought behind game balancing, an aspect of game development that sparked learning and research. From the experience of developing *Dino Tower Defense*, we hope to continue implementing the best practices of object oriented design into any future code we write.

#### Citations

Rhio Sutoyo, Davies Winata, Katherine Oliviani, Dedy Martadinata Supriyadi. Dynamic Difficulty Adjustment 		in Tower Defense. Procedia Computer Science, Volume 59, 2015. Pages  435-444, https://doi.org/10.101		6/j.procs.2015.07.563.
